import { NextRequest, NextResponse } from 'next/server';

// Suno API base URL (sunoapi.org)
const SUNO_API_BASE = 'https://api.sunoapi.org/api/v1';

interface SunoGenerateRequest {
  prompt: string;
  make_instrumental?: boolean;
  wait_audio?: boolean;
  tags?: string;
  title?: string;
  model?: string;
  callBackUrl?: string;
}

interface SunoGenerateResponse {
  id: string;
  audio_url?: string;
  video_url?: string;
  image_url?: string;
  image_large_url?: string;
  status: string;
  title?: string;
  tags?: string;
  prompt?: string;
  duration?: number;
}

export async function POST(request: NextRequest) {
  try {
    const { prompt, genre, mood, duration, bpm, rawPrompt } = await request.json();

    if (!prompt && !rawPrompt) {
      return NextResponse.json(
        { error: 'Prompt is required' },
        { status: 400 }
      );
    }

    if (!process.env.SUNO_API_KEY) {
      return NextResponse.json(
        { error: 'Suno API key not configured. Please add SUNO_API_KEY to your environment variables.' },
        { status: 500 }
      );
    }

    console.log('üéµ Generating music with Suno API:', {
      genre,
      mood,
      duration,
      bpm,
      prompt: rawPrompt || prompt,
    });

    // Enhanced prompt for music generation
    const musicPrompt = rawPrompt || prompt || `${genre} music with ${mood} mood`;
    
    // Build tags string from genre and mood for better generation
    const tags = [genre, mood, bpm ? `${bpm} BPM` : null]
      .filter(Boolean)
      .join(', ');

    // Construct callback URL
    const protocol = request.headers.get('x-forwarded-proto') || 'http';
    const host = request.headers.get('host');
    const callBackUrl = `${protocol}://${host}/api/generate/audio/suno/callback`;

    // Prepare Suno API request
    const sunoRequest: SunoGenerateRequest = {
      prompt: musicPrompt,
      make_instrumental: false, // Allow vocals for full music experience
      wait_audio: true, // Wait for audio to be generated
      tags,
      model: 'V4', // Use V4 model for balanced quality and speed
      callBackUrl,
    };

    console.log('üéµ Sending request to Suno API:', sunoRequest);

    // Call Suno API
    const response = await fetch(`${SUNO_API_BASE}/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.SUNO_API_KEY}`,
      },
      body: JSON.stringify(sunoRequest),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Suno API error:', response.status, errorText);
      throw new Error(`Suno API error: ${response.status} - ${errorText}`);
    }

    const rawData = await response.json();
    console.log('üéµ Raw Suno API response:', JSON.stringify(rawData, null, 2));
    
    // Handle both array and single object responses
    let data: SunoGenerateResponse[];
    if (Array.isArray(rawData)) {
      data = rawData;
    } else if (rawData && typeof rawData === 'object') {
      // If it's a single object, wrap it in an array
      data = [rawData as SunoGenerateResponse];
    } else {
      console.error('‚ùå Unexpected Suno API response structure:', rawData);
      throw new Error('Unexpected response format from Suno API');
    }
    
    if (!data || data.length === 0) {
      throw new Error('No audio generated by Suno API');
    }

    const firstTrack = data[0];
    
    if (!firstTrack) {
      console.error('‚ùå First track is undefined. Data:', data);
      throw new Error('Invalid response: No track data available');
    }
    
    // If audio_url is not available yet, we might need to poll for it
    // For now, we'll return what we got
    if (!firstTrack.audio_url) {
      console.warn('‚ö†Ô∏è Audio URL not immediately available, status:', firstTrack.status);
      // Try to fetch the track by ID after a brief wait
      if (firstTrack.id) {
        console.log('üîÑ Polling for audio URL...');
        const audioUrl = await pollForAudioUrl(firstTrack.id);
        if (audioUrl) {
          firstTrack.audio_url = audioUrl;
        }
      }
    }

    // Final validation before returning
    if (!firstTrack.audio_url) {
      console.error('‚ùå No audio URL available after polling');
      return NextResponse.json(
        { error: 'Audio generation timed out. The audio is still being processed. Please try again in a moment.' },
        { status: 202 } // 202 Accepted - request is still being processed
      );
    }

    console.log('‚úÖ Suno music generation successful:', {
      id: firstTrack.id,
      status: firstTrack.status,
      hasAudio: !!firstTrack.audio_url,
    });

    return NextResponse.json({
      audioUrl: firstTrack.audio_url,
      prompt: musicPrompt,
      sunoId: firstTrack.id,
      metadata: {
        genre,
        mood,
        duration: firstTrack.duration || duration,
        bpm,
        service: 'suno',
        title: firstTrack.title,
        tags: firstTrack.tags,
        status: firstTrack.status,
      },
    });
  } catch (error: any) {
    console.error('üéµ Suno music generation error:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to generate music' },
      { status: 500 }
    );
  }
}

// Helper function to poll for audio URL when it's not immediately available
async function pollForAudioUrl(trackId: string, maxAttempts = 30): Promise<string | null> {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds between polls
      
      const response = await fetch(`${SUNO_API_BASE}/get?ids=${trackId}`, {
        headers: {
          'Authorization': `Bearer ${process.env.SUNO_API_KEY || ''}`,
        },
      });

      if (response.ok) {
        const data: SunoGenerateResponse[] = await response.json();
        if (data && data.length > 0 && data[0].audio_url) {
          console.log(`‚úÖ Audio URL ready after ${(i + 1) * 2} seconds`);
          return data[0].audio_url;
        }
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Poll attempt ${i + 1} failed:`, error);
    }
  }
  
  console.error('‚ùå Failed to get audio URL after polling');
  return null;
}

